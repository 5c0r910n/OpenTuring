#include "cinterface"
static struct {
    TLint4	dummy;
    char	dummy2[840];
} TLFTAB =
    { 17,
    {'/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 'b', 'd', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', '.', '.', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '/', 'f', 'i', 'l', 'e', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'u', 'm', 'm', 'y', '.', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'n', 'v', 'i', 'r', 'o', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'm', 's', 'g', 's', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'e', 'b', 'u', 'g', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '/', 'u', 'n', 'i', 't', 'm', 'a', 'n', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'r', 'r', 'o', 'r', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'p', 's', 'e', 'u', 'd', 'o', '.', 'd', 'e', 'f', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'o', 'p', 'c', 'o', 'd', 'e', '.', 'i', 'n', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'd', 'e', 'b', 'u', 'g', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '/', 'c', 'o', 'm', 'p', 'i', 'l', 'e', '.', 's', 't', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'e', 'x', 'e', 'c', 'u', 't', 'o', 'r', '/', 'e', 'x', 'e', 'c', 'u', 't', 'e', '.', 's', 't', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'D', 'O', 'S', '3', '2', '/', 'm', 'e', 'm', 'o', 'r', 'y', '\0',
    '/', 'l', 'o', 'c', 'a', 'l', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '/', 't', 'p', 'l', 'u', 's', '/', 'c', 'o', 'm', 'm', 'o', 'n', '/', 's', 'y', 's', 't', 'e', 'm', '\0',
    '/', 'e', 'x', 'p', 'o', 'r', 't', '/', 'h', 'o', 'm', 'e', '/', 't', 'u', 'r', 'i', 'n', 'g', '/', 'o', 'o', 't', '/', 's', 'r', 'c', '/', 'l', 'a', 'n', 'g', 'u', 'a', 'g', 'e', '/', 'p', 'a', 'r', 'a', '/', 'p', 'a', 'r', 'a', 'O', 'O', 'T', '.', 'c', 'h', '\0'
    }};
typedef	TLnat2	FileManager_FileNoType;
typedef	TLnat4	FileManager_FileTimeStamp;
typedef	TLint2	FileManager_ResultCode;

extern void FileManager_OpenNamedHandle ();

extern void FileManager_OpenUnnamedHandle ();

extern void FileManager_OpenFileHandle ();

extern void FileManager_SetModified ();

extern void FileManager_WriteFile ();

extern void FileManager_WriteBackup ();

extern void FileManager_WriteTemp ();

extern void FileManager_RmTemp ();

extern void FileManager_CloseFileHandle ();

extern void FileManager_OpenNamedText ();

extern void FileManager_OpenFileText ();

extern void FileManager_CloseFileText ();

extern void FileManager_CloseAllText ();

extern void FileManager_ChangeDirectory ();

extern void FileManager_GetDirectory ();

extern void FileManager_ChangeExecDirectory ();

extern void FileManager_GetExecDirectory ();

extern void FileManager_ShortName ();

extern void FileManager_RelativeName ();

extern void FileManager_PathName ();

extern void FileManager_ExecPathName ();

extern void FileManager_ExtendName ();

extern void FileManager_FileName ();

extern TLboolean FileManager_IsUnnamed ();

extern TLboolean FileManager_IsOnDisk ();

extern TLboolean FileManager_IsSameFile ();

extern TLboolean FileManager_IsReadOK ();

extern TLboolean FileManager_IsWriteOK ();

extern TLboolean FileManager_IsOlder ();

extern TLboolean FileManager_FileExists ();

extern void FileManager_AddReference ();

extern void FileManager_DeleteReference ();

extern void FileManager_ReadTimeStamp ();

extern void FileManager_FlushUnreferencedFiles ();

extern void FileManager_CheckReferencedFiles ();

extern void FileManager_RmFile ();

extern void FileManager_SetDefaultInclude ();

extern void FileManager_AssertTextClosed ();

extern void FileManager_Dump ();

extern TLboolean AbortCheck ();

extern void FeedBack ();
struct	SrcPosition {
    TLnat2	lineNo;
    FileManager_FileNoType	fileNo;
    TLnat2	linePos;
    TLnat2	tokLen;
};
typedef	TLchar	__x1100[256];
struct	ErrMsgDef {
    struct ErrMsgDef	*next;
    struct SrcPosition	srcPos;
    __x1100	text;
};
typedef	TLint4	CookieKind;
struct	Cookie {
    CookieKind	kind;
    TLaddressint	item;
    TLaddressint	fp;
    TLaddressint	data;
};
struct	CallDef {
    struct CallDef	*next;
    TLstring	routineName;
    struct SrcPosition	srcPos;
    struct Cookie	cookie;
};
struct	ThreadDef {
    struct ThreadDef	*next;
    TLaddressint	threadId;
    TLaddressint	threadName;
    struct CallDef	*traceback;
};
struct	ThreadQueueDef {
    struct ThreadQueueDef	*next;
    TLaddressint	queueId;
    TLstring	queueName;
    struct ThreadDef	*threadList;
};
struct	DumpIndexDef {
    struct DumpIndexDef	*next;
    TLint4	lowerBound;
    TLint4	upperBound;
};
struct	DumpSymbolDef {
    struct DumpSymbolDef	*next;
    TLaddressint	symbolName;
    TLaddressint	typeName;
    struct SrcPosition	srcPos;
    TLstring	value;
    struct Cookie	cookie;
    TLboolean	isPredef;
};
struct	DumpScopeDef {
    struct DumpSymbolDef	symbolInfo;
    struct Cookie	expandCookie;
    struct DumpSymbolDef	*parameters;
    struct DumpSymbolDef	*declarations;
};

void Language_Debugging ();

void Language_Paragraph ();

void Language_Reset ();

void Language_SetMaxErrorCount ();
typedef	TLstring	__x1101[20];

void Language_EnterPreprocSymbols ();

void Language_CompileUnit ();

void Language_CompileProgram ();

void Language_WriteObjectFile ();
typedef	TLstring	__x1104[21];

static void Language_SetupExecutionFromObjectFile ();

static void Language_GetFileName ();
typedef	TLstring	__x1108[21];

void Language_SetupExecution ();
typedef	TLint1	Language_Step;

void Language_SetStep ();
typedef	TLint1	Language_ReturnState;
struct	Language_RunStatus {
    Language_ReturnState	state;
    TLint4	moreStateInfo;
    struct SrcPosition	srcPos;
    TLaddressint	threadId;
};

void Language_ExecuteProgram ();

void Language_EndExecution ();

void Language_StopExecution ();

void Language_DumpThreadList ();

void Language_DumpUnitList ();

void Language_DumpScopeInfo ();

void Language_DumpSymbolInfo ();

void Language_DumpArrayBounds ();

void Language_DumpArrayValues ();
TLboolean	Language_debug;

void Language_Debugging (val)
TLboolean	val;
{
    TLSTKCHKSLF(100065);
    TLSETF();
    TLSETL(100065);
    Language_debug = val;
    TLRESTORELF();
}
struct SrcPosition	Language_nullSrcPosition = 
    {0, 0, 0, 0};
struct Cookie	Language_nullCookie = 
    {0, 0, 0, 0};
struct DumpSymbolDef	Language_nullSymbolDef;
struct DumpScopeDef	Language_nullScopeDef;
typedef	TLint1	Language_UnitManager_UnitKind;
typedef	TLint1	Language_UnitManager_UnitStatus;

extern void Language_UnitManager_AddDepend ();

extern void Language_UnitManager_AddIncludeFile ();

extern void Language_UnitManager_AllocateCompileChunk ();

extern void * Language_UnitManager_BodyUnit ();

extern void Language_UnitManager_ClearAllMarks ();

extern void Language_UnitManager_ClearConfiguration ();

extern TLaddressint Language_UnitManager_CodeTable ();

extern FileManager_FileNoType Language_UnitManager_FileNo ();

extern void Language_UnitManager_FlushOldUnits ();

extern void Language_UnitManager_GetNextDepend ();

extern void Language_UnitManager_GetNextUnit ();

extern void Language_UnitManager_GetUnitPtr ();

extern TLaddressint Language_UnitManager_GlobalArea ();

extern TLint4 Language_UnitManager_GlobalSize ();

extern TLboolean Language_UnitManager_IsCompiled ();

extern TLboolean Language_UnitManager_IsMarked ();

extern TLboolean Language_UnitManager_IsPredef ();

extern Language_UnitManager_UnitKind Language_UnitManager_Kind ();

extern TLaddressint Language_UnitManager_ManifestTable ();

extern void * Language_UnitManager_OverrideBody ();

extern void Language_UnitManager_PrepareForCompile ();

extern void Language_UnitManager_PrepareForDepends ();

extern void Language_UnitManager_PrepareForScan ();

extern void Language_UnitManager_Reset ();

extern void Language_UnitManager_RewindDependList ();

extern void Language_UnitManager_RewindUnitList ();

extern void Language_UnitManager_SetCodeTable ();

extern void Language_UnitManager_SetDefaultBody ();

extern void Language_UnitManager_SetGlobalArea ();

extern void Language_UnitManager_SetKind ();

extern void Language_UnitManager_SetManifestTable ();

extern void Language_UnitManager_SetMark ();

extern void Language_UnitManager_SetOverrideBody ();

extern void Language_UnitManager_SetPredef ();

extern void Language_UnitManager_SetStub ();

extern void Language_UnitManager_SetSymbolTable ();

extern void Language_UnitManager_StartNewProgram ();

extern void * Language_UnitManager_StubUnit ();

extern void Language_UnitManager_SuccessfulCompile ();

extern TLaddressint Language_UnitManager_SymbolTable ();
typedef	TLint1	Language_ErrorModule_Severity;

extern void Language_ErrorModule_Initialize ();

extern void Language_ErrorModule_SetMaxErrors ();

extern void Language_ErrorModule_Message ();

extern void Language_ErrorModule_AbortIfErrors ();

extern void Language_ErrorModule_ReturnErrors ();
typedef	Language_ErrorModule_Severity	Language_ErrorSeverity;

void Language_SetMaxErrorCount (maxErrorCount)
TLint4	maxErrorCount;
{
    TLSTKCHKSLF(100109);
    TLSETF();
    TLSETL(100109);
    Language_ErrorModule_SetMaxErrors((TLint4) maxErrorCount);
    TLRESTORELF();
}
typedef	TLstring	Language_StringDef;
typedef	TLnat4	Language_Offset;
TLint4	Language_codeOprSize;
TLint4	Language_codeInt1Size;
TLint4	Language_codeInt2Size;
TLint4	Language_codeIntSize;
TLint4	Language_codeRealSize;
TLint4	Language_codeAddrSize;
TLint4	Language_codeOffsetSize;
typedef	TLchar	Language_string1[2];
typedef	TLnat1	Language_set8;
typedef	TLnat2	Language_set16;
typedef	TLnat4	Language_set32;
typedef	TLint2	Language_Opcode;
typedef	TLchar	Language___x1112[22];
typedef	Language___x1112	Language___x1111[255];
Language___x1111	Language_OpcodeName = 
    {"ABORT", "ABORTCOND", "ABSINT", "ABSREAL", "ADDINT", "ADDINTNAT", "ADDNAT", "ADDNATINT", "ADDREAL", "ADDSET",
    "ALLOCFLEXARRAY", "ALLOCGLOB", "ALLOCGLOBARRAY", "ALLOCLOC", "ALLOCLOCARRAY", "AND", "ARRAYUPPER", "ASNADDR", "ASNADDRINV", "ASNINT",
    "ASNINTINV", "ASNINT1", "ASNINT1INV", "ASNINT2", "ASNINT2INV", "ASNINT4", "ASNINT4INV", "ASNNAT", "ASNNATINV", "ASNNAT1",
    "ASNNAT1INV", "ASNNAT2", "ASNNAT2INV", "ASNNAT4", "ASNNAT4INV", "ASNNONSCALAR", "ASNNONSCALARINV", "ASNPTR", "ASNPTRINV", "ASNREAL",
    "ASNREALINV", "ASNREAL4", "ASNREAL4INV", "ASNREAL8", "ASNREAL8INV", "ASNSTR", "ASNSTRINV", "BEGINHANDLER", "BITSASSIGN", "BITSEXTRACT",
    "CALL", "CALLEXTERNAL", "CALLIMPLEMENTBY", "CASE", "CAT", "CHARSUBSTR1", "CHARSUBSTR2", "CHARTOCSTR", "CHARTOSTR", "CHARTOSTRLEFT",
    "CHKCHRSTRSIZE", "CHKCSTRRANGE", "CHKRANGE", "CHKSTRRANGE", "CHKSTRSIZE", "CLOSE", "COPYARRAYDESC", "CSTRTOCHAR", "CSTRTOSTR", "CSTRTOSTRLEFT",
    "DEALLOCFLEXARRAY", "DECSP", "DIVINT", "DIVNAT", "DIVREAL", "EMPTY", "ENDFOR", "EOF", "EQADDR", "EQCHARN",
    "EQINT", "EQINTNAT", "EQNAT", "EQREAL", "EQSET", "EQSTR", "EXPINTINT", "EXPREALINT", "EXPREALREAL", "FETCHADDR",
    "FETCHBOOL", "FETCHINT", "FETCHINT1", "FETCHINT2", "FETCHINT4", "FETCHNAT", "FETCHNAT1", "FETCHNAT2", "FETCHNAT4", "FETCHPTR",
    "FETCHREAL", "FETCHREAL4", "FETCHREAL8", "FETCHSET", "FETCHSTR", "FIELD", "FOR", "FORK", "FREE", "FREECLASS",
    "FREEU", "GECHARN", "GECLASS", "GEINT", "GEINTNAT", "GENAT", "GENATINT", "GEREAL", "GESET", "GESTR",
    "GET", "GETPRIORITY", "GTCLASS", "IF", "IN", "INCLINENO", "INCSP", "INFIXAND", "INFIXOR", "INITARRAYDESC",
    "INITCONDITION", "INITMONITOR", "INITUNIT", "INTREAL", "INTREALLEFT", "INTSTR", "JSR", "JUMP", "JUMPB", "LECHARN",
    "LECLASS", "LEINT", "LEINTNAT", "LENAT", "LENATINT", "LEREAL", "LESET", "LESTR", "LOCATEARG", "LOCATECLASS",
    "LOCATELOC", "LOCATEPARM", "LOCATETEMP", "LTCLASS", "MAXINT", "MAXNAT", "MAXREAL", "MININT", "MINNAT", "MINREAL",
    "MODINT", "MODNAT", "MODREAL", "MONITORENTER", "MONITOREXIT", "MULINT", "MULNAT", "MULREAL", "MULSET", "NATREAL",
    "NATREALLEFT", "NATSTR", "NEGINT", "NEGREAL", "NEW", "NEWARRAY", "NEWCLASS", "NEWU", "NOT", "NUMARRAYELEMENTS",
    "OBJCLASS", "OPEN", "OR", "ORD", "PAUSE", "PRED", "PROC", "PUSHADDR", "PUSHADDR1", "PUSHCOPY",
    "PUSHINT", "PUSHINT1", "PUSHINT2", "PUSHREAL", "PUSHVAL0", "PUSHVAL1", "PUT", "QUIT", "READ", "REALDIVIDE",
    "REMINT", "REMREAL", "RESOLVEDEF", "RESOLVEPTR", "RESTORESP", "RETURN", "RTS", "SAVESP", "SEEK", "SEEKSTAR",
    "SETALL", "SETCLR", "SETELEMENT", "SETFILENO", "SETLINENO", "SETPRIORITY", "SETSTDSTREAM", "SETSTREAM", "SHL", "SHR",
    "SIGNAL", "STRINT", "STRINTOK", "STRNAT", "STRNATOK", "STRTOCHAR", "SUBINT", "SUBINTNAT", "SUBNAT", "SUBNATINT",
    "SUBREAL", "SUBSCRIPT", "SUBSET", "SUBSTR1", "SUBSTR2", "SUCC", "TAG", "TELL", "UFIELD", "UNINIT",
    "UNINITADDR", "UNINITBOOLEAN", "UNINITINT", "UNINITNAT", "UNINITREAL", "UNINITSTR", "UNLINKHANDLER", "VSUBSCRIPT", "WAIT", "WRITE",
    "XOR", "XORSET", "BREAK", "SYSEXIT", "ILLEGAL"};
struct	Language_CodeHeader {
    TLaddressint	bodyCode;
};
struct	Language___x1114 {
    TLint4	lower, range;
};
typedef	struct Language___x1114	Language___x1113[255];
struct	Language_ArrayDescriptor {
    TLnat4	sizeArray;
    TLnat4	sizeElement;
    TLnat4	elementCount;
    TLnat4	numDimensions;
    Language___x1113	dim;
};
struct	Language_ForDescriptor {
    TLint4	counter;
    TLint4	right;
    TLint4	step;
    TLaddressint	savedSP;
};
typedef	Language_Offset	Language___x1115[1001];
struct	Language_CaseDescriptor {
    TLint4	lower, upper;
    Language_Offset	otherwise;
    Language___x1115	caseVector;
};
struct	Language_PointerDescriptor {
    TLaddressint	dataPtr;
    TLint4	timestamp;
};
typedef	TLnat2	Language___x1116[301];
struct	Language_UnionMapDescriptor {
    TLint4	lower, upper;
    Language___x1116	map;
};
typedef	TLnat4	Language_ClassAttr;
struct	Language_ClassDescriptor {
    TLaddressint	baseClass;
    TLaddressint	expandClass;
    Language_ClassAttr	attributes;
    TLnat4	objSize;
    TLaddressint	classId;
    TLaddressint	initRoutine;
    TLnat4	numOperations;
};
typedef	TLint1	Language_OpenKind;
typedef	TLint1	Language_PutKind;
typedef	TLint1	Language_GetKind;
typedef	TLint1	Language_SetStreamKind;
typedef	TLnat1	Language_StreamModeSet;
typedef	TLint1	Language_SubstringKind;
typedef	TLint1	Language_RangeCheckKind;
typedef	TLint1	Language_ConditionKind;

extern void Language_DebugModule_Initialize ();

extern void Language_DebugModule_NewQueue ();

extern void Language_DebugModule_NewThread ();

extern void Language_DebugModule_NewCall ();

extern void Language_DebugModule_ReturnThreadDump ();

extern void Language_DebugModule_NewSymbolList ();

extern void Language_DebugModule_NewSymbol ();

extern void Language_DebugModule_ReturnSymbolDump ();

extern void Language_DebugModule_NewIndexList ();

extern void Language_DebugModule_NewIndex ();

extern void Language_DebugModule_ReturnIndexDump ();

extern void Language_Compile_Reset ();

extern void Language_Compile_Initialize ();
typedef	TLstring	__x1119[20];

extern void Language_Compile_EnterPreprocSymbols ();

extern void Language_Compile_ScanUnit ();

extern void Language_Compile_CompileUnit ();

extern void Language_Compile_InstallUnit ();

extern void Language_Compile_CallInfo ();

extern void Language_Compile_DumpUnitList ();

extern void Language_Compile_DumpScopeInfo ();

extern void Language_Compile_DumpSymbolInfo ();

extern void Language_Compile_DumpArrayBounds ();

extern void Language_Compile_DumpArrayValues ();

extern void Language_Compile_SetObjectFileStream ();
typedef	TLstring	__x1122[21];

extern void Language_Execute_Initialize ();

extern TLint4 Language_Execute_GetStackAllocated ();

extern void Language_Execute_Executor ();

extern void Language_Execute_EndExecution ();

extern void Language_Execute_RecoverAllMemory ();

extern void Language_Execute_SetStep ();

extern void Language_Execute_DumpThreadList ();

extern void Language_Execute_UnitInitState ();

extern TLaddressint malloc ();

extern TLaddressint realloc ();

extern void free ();

void Language_Reset () {
    TLSTKCHKSLF(100171);
    TLSETF();
    TLSETL(100171);
    Language_ErrorModule_Initialize();
    TLSETL(100174);
    Language_UnitManager_Reset();
    TLSETL(100177);
    Language_DebugModule_Initialize();
    TLSETL(100180);
    Language_Compile_Reset();
    TLSETL(100182);
    Language_Execute_RecoverAllMemory();
    TLRESTORELF();
}
typedef	TLstring	Language___x1125[20];
static Language___x1125	Language_preprocDefs;
static TLint4	Language_preprocCount;
static TLboolean	Language_newPreprocs;

void Language_EnterPreprocSymbols (defs, numDefs)
__x1101	defs;
TLint4	numDefs;
{
    TLSTKCHKSLF(100193);
    TLSETF();
    TLSETL(100193);
    TLNONSCLASS(Language_preprocDefs, defs, Language___x1125);
    TLINCL();
    Language_preprocCount = numDefs;
    TLINCL();
    Language_newPreprocs = 1;
    TLRESTORELF();
}
static void	*Language_mainUnitPtr;

static void Language_Initialize () {
    TLSTKCHKSLF(100209);
    TLSETF();
    TLSETL(100209);
    Language_ErrorModule_Initialize();
    TLSETL(100213);
    Language_DebugModule_Initialize();
    if (Language_newPreprocs) {
	TLSETL(100215);
	Language_UnitManager_Reset();
	TLINCL();
	Language_Compile_Reset();
	TLINCL();
	Language_Compile_Initialize();
	TLINCL();
	Language_Compile_EnterPreprocSymbols(Language_preprocDefs, (TLint4) Language_preprocCount);
	Language_newPreprocs = 0;
    } else {
	TLSETL(100221);
	Language_Compile_Initialize();
    };
    TLSETL(100231);
    Language_Execute_RecoverAllMemory();
    TLINCL();
    Language_UnitManager_StartNewProgram();
    Language_mainUnitPtr = (void *) 0;
    TLRESTORELF();
}
extern TLint4	TL_TLI_TLIARC;

extern void TL_TLI_TLIFA ();

extern void TL_TLX_TLXGE ();

extern void TL_TLX_TLXDT ();

extern void TL_TLX_TLXTM ();

extern void TL_TLX_TLXCL ();

extern void TL_TLX_TLXSC ();

extern void time ();

extern void TL_TLX_TLXSYS ();

extern TLint4 getpid ();

extern void TL_TLI_TLIFS ();

extern void TL_TLK_TLKUEXIT ();
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKUDMPA ();

extern void TL_TLK_TLKCINI ();
extern TLboolean	TL_TLK_TLKCLKON;
extern TLnat4	TL_TLK_TLKHZ;
extern TLnat4	TL_TLK_TLKCRESO;
extern TLnat4	TL_TLK_TLKTIME;
extern TLnat4	TL_TLK_TLKEPOCH;

extern void TL_TLK_TLKPSID ();

extern TLnat4 TL_TLK_TLKPGID ();

extern void TL_TLK_TLKRSETP ();

static void Language_ScanUnitPtr (unitPtr, unitKind)
void	*unitPtr;
Language_UnitManager_UnitKind	unitKind;
{
    Language_UnitManager_UnitStatus	unitStatus;
    void	*bodyUnit;
    TLSTKCHKSLF(100247);
    TLSETF();
    TLSETL(100247);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100251);
    Language_UnitManager_PrepareForScan(unitPtr, &(unitStatus));
    if (unitStatus == 2) {
	TLSETL(100256);
	TLRESTORELF();
	return;
    };
    TLSETL(100258);
    if (AbortCheck()) {
	TLSETL(100259);
	TL_TLE_TLEQUIT ((TLint4) 1, (char *) 0, 0);
    };
    TLSETL(100262);
    if (unitStatus == 0) {
	TLSETL(100264);
	if (Language_debug) {
	    FileManager_FileNoType	fileNo;
	    TLSETL(100265);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Scanning ", (TLint2) 0);
	    TLINCL();
	    fileNo = Language_UnitManager_FileNo(unitPtr);
	    TLSETL(100268);
	    if (fileNo == 0) {
		TLSETL(100269);
		TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
		TL_TLI_TLIPS ((TLint4) 0, "builtins", (TLint2) 0);
		TL_TLI_TLIPK ((TLint2) 0);
	    } else {
		TLSETL(100271);
		{
		    TLstring	__x1130;
		    FileManager_FileName((FileManager_FileNoType) fileNo, __x1130);
		    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
		    TL_TLI_TLIPS ((TLint4) 0, __x1130, (TLint2) 0);
		    TL_TLI_TLIPK ((TLint2) 0);
		};
	    };
	};
	TLSETL(100276);
	Language_Compile_ScanUnit(unitPtr, (Language_UnitManager_UnitKind) unitKind);
	TLSETL(100278);
	Language_ErrorModule_AbortIfErrors();
	TLSETL(100280);
	FileManager_AssertTextClosed();
    };
    TLSETL(100286);
    Language_UnitManager_RewindDependList(unitPtr);
    switch (Language_UnitManager_Kind(unitPtr)) {
	case 3:
	    {
		void	*mainUnit;
		TLSETL(100290);
		Language_UnitManager_GetNextDepend(unitPtr, &(mainUnit));
		TLASSERT (mainUnit != ((void *) 0));
		TLSETL(100292);
		Language_ScanUnitPtr(mainUnit, (Language_UnitManager_UnitKind) 5);
	    }
	    break;
	case 5:
	    {
		TLSETL(100293);
		if (Language_mainUnitPtr == ((void *) 0)) {
		    TLSETL(100294);
		    Language_mainUnitPtr = unitPtr;
		};
	    }
	    break;
	default :
	    break;
    };
    TLSETL(100299);
    for(;;) {
	void	*dependUnit;
	TLSETL(100301);
	Language_UnitManager_GetNextDepend(unitPtr, &(dependUnit));
	if (dependUnit == ((void *) 0)) {
	    break;
	};
	TLSETL(100303);
	Language_ScanUnitPtr(dependUnit, (Language_UnitManager_UnitKind) 4);
    };
    TLSETL(100305);
    bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
    TLINCL();
    if (bodyUnit != ((void *) 0)) {
	TLSETL(100308);
	Language_ScanUnitPtr(bodyUnit, (Language_UnitManager_UnitKind) 4);
    };
    TLRESTORELF();
}

static void Language_ScanPredefs () {
    FileManager_FileNoType	fileNo;
    TLaddressint	textPtr;
    FileManager_ResultCode	resultCode;
    TLstring	predefFile;
    void	*unitPtr;
    TLSTKCHKSLF(100321);
    TLSETF();
    TLSETL(100321);
    {
	TLstring	__x1131;
	FileManager_PathName("%oot/support/predefs/predefs.lst", __x1131);
	TLSTRASS(255, predefFile, __x1131);
    };
    TLSETL(100331);
    FileManager_OpenNamedText(predefFile, (FileManager_FileNoType) 0, &(fileNo), &(textPtr), &(resultCode));
    if (fileNo == 0) {
	TLSETL(100335);
	{
	    TLstring	__x1133;
	    TL_TLS_TLSCAT("Unable to open predefs list file \'", predefFile, __x1133);
	    {
		TLstring	__x1132;
		TL_TLS_TLSCAT(__x1133, "\'", __x1132);
		Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1132);
	    };
	};
    } else {
	TLSETL(100335);
	if (resultCode == 3) {
	    struct SrcPosition	srcPos;
	    TLSETL(100336);
	    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    srcPos.fileNo = fileNo;
	    TLSETL(100340);
	    Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 1, "Predefs list file contains non-ascii characters (deleted)");
	};
    };
    TLSETL(100343);
    FileManager_CloseFileText((FileManager_FileNoType) fileNo);
    TLSETL(100345);
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) fileNo, &(unitPtr));
    if (unitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100346);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = fileNo;
	TLSETL(100351);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for unit descriptor");
    };
    TLSETL(100354);
    Language_ScanUnitPtr(unitPtr, (Language_UnitManager_UnitKind) 2);
    TLRESTORELF();
}

static void Language_CompileUnitPtr (unitPtr)
void	*unitPtr;
{
    Language_UnitManager_UnitStatus	unitStatus;
    FileManager_FileNoType	fileNo;
    TLstring	unitName;
    TLSTKCHKSLF(100358);
    TLSETF();
    TLSETL(100358);
    TLPRE (unitPtr != ((void *) 0));
    TLSETL(100362);
    Language_UnitManager_PrepareForDepends(unitPtr, &(unitStatus));
    if (unitStatus == 2) {
	TLSETL(100367);
	TLRESTORELF();
	return;
    };
    TLSETL(100369);
    if (AbortCheck()) {
	TLSETL(100370);
	TL_TLE_TLEQUIT ((TLint4) 1, (char *) 0, 0);
    };
    TLSETL(100376);
    if (Language_UnitManager_Kind(unitPtr) == 3) {
	TLSETL(100377);
	TLASSERT (Language_mainUnitPtr != ((void *) 0));
	TLSETL(100379);
	Language_CompileUnitPtr(Language_mainUnitPtr);
    } else {
	TLSETL(100381);
	Language_UnitManager_RewindDependList(unitPtr);
	TLINCL();
	for(;;) {
	    void	*dependUnit;
	    TLSETL(100384);
	    Language_UnitManager_GetNextDepend(unitPtr, &(dependUnit));
	    if (dependUnit == ((void *) 0)) {
		break;
	    };
	    TLSETL(100386);
	    Language_CompileUnitPtr(dependUnit);
	};
    };
    TLSETL(100392);
    fileNo = Language_UnitManager_FileNo(unitPtr);
    TLSETL(100394);
    if (fileNo == 0) {
	TLSETL(100395);
	TLSTRASS(255, unitName, "builtins");
    } else {
	TLSETL(100397);
	{
	    TLstring	__x1134;
	    FileManager_FileName((FileManager_FileNoType) fileNo, __x1134);
	    TLSTRASS(255, unitName, __x1134);
	};
    };
    TLSETL(100413);
    Language_UnitManager_PrepareForCompile(unitPtr, &(unitStatus));
    if (unitStatus != 1) {
	TLSETL(100415);
	if (Language_debug) {
	    TLSETL(100416);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Compiling ", (TLint2) 0);
	    TL_TLI_TLIPS ((TLint4) 0, unitName, (TLint2) 0);
	    TL_TLI_TLIPK ((TLint2) 0);
	};
	TLSETL(100420);
	{
	    TLstring	__x1135;
	    TL_TLS_TLSCAT("Compiling ", unitName, __x1135);
	    FeedBack(__x1135);
	};
	TLINCL();
	Language_Compile_CompileUnit(unitPtr);
	TLINCL();
	TL_TLI_TLIFS();
	TLSETL(100424);
	Language_ErrorModule_AbortIfErrors();
	TLSETL(100426);
	FileManager_AssertTextClosed();
	TLSETL(100434);
	Language_UnitManager_SuccessfulCompile(unitPtr);
    } else {
	TLSETL(100442);
	if (Language_debug) {
	    TLSETL(100443);
	    TL_TLI_TLISS ((TLint4) 0, (TLint2) 2);
	    TL_TLI_TLIPS ((TLint4) 0, "Installing ", (TLint2) 0);
	    TL_TLI_TLIPS ((TLint4) 0, unitName, (TLint2) 0);
	    TL_TLI_TLIPK ((TLint2) 0);
	};
	TLSETL(100448);
	Language_Compile_InstallUnit(unitPtr);
    };
    TLRESTORELF();
}
static void	*Language_lastCompileUnit;

static void Language_CompileFile (fileName, fileNo, canBeUnit)
TLstring	fileName;
FileManager_FileNoType	fileNo;
TLboolean	canBeUnit;
{
    FileManager_FileNoType	compileFileNo;
    void	*compileUnitPtr;
    TLSTKCHKSLF(100458);
    TLSETF();
    TLSETL(100458);
    Language_Initialize();
    compileFileNo = fileNo;
    TLINCL();
    if (compileFileNo == 0) {
	TLaddressint	textPtr;
	FileManager_ResultCode	resultCode;
	TLSETL(100464);
	FileManager_OpenNamedText(fileName, (FileManager_FileNoType) 0, &(compileFileNo), &(textPtr), &(resultCode));
	if (compileFileNo == 0) {
	    TLSETL(100469);
	    {
		TLstring	__x1140;
		FileManager_PathName(fileName, __x1140);
		{
		    TLstring	__x1139;
		    TL_TLS_TLSCAT("Unable to open file \"", fileName, __x1139);
		    {
			TLstring	__x1138;
			TL_TLS_TLSCAT(__x1139, "\" [\"", __x1138);
			{
			    TLstring	__x1137;
			    TL_TLS_TLSCAT(__x1138, __x1140, __x1137);
			    {
				TLstring	__x1136;
				TL_TLS_TLSCAT(__x1137, "\"]", __x1136);
				Language_ErrorModule_Message(&(Language_nullSrcPosition), (Language_ErrorModule_Severity) 3, __x1136);
			    };
			};
		    };
		};
	    };
	} else {
	    TLSETL(100469);
	    if (resultCode == 3) {
		struct SrcPosition	srcPos;
		TLSETL(100470);
		TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
		TLINCL();
		srcPos.fileNo = compileFileNo;
		TLSETL(100475);
		{
		    TLstring	__x1142;
		    TL_TLS_TLSCAT("File \"", fileName, __x1142);
		    {
			TLstring	__x1141;
			TL_TLS_TLSCAT(__x1142, "\" contains non-ascii characters (deleted)", __x1141);
			Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 1, __x1141);
		    };
		};
	    };
	};
	TLSETL(100477);
	FileManager_CloseFileText((FileManager_FileNoType) compileFileNo);
    };
    TLSETL(100485);
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) 0, &(compileUnitPtr));
    if (compileUnitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100486);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = compileFileNo;
	TLSETL(100491);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for builtin unit descriptor");
    };
    TLSETL(100493);
    FeedBack("Initializing builtins");
    TLINCL();
    Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 1);
    TLSETL(100499);
    Language_CompileUnitPtr(compileUnitPtr);
    TLINCL();
    Language_UnitManager_GetUnitPtr((FileManager_FileNoType) compileFileNo, &(compileUnitPtr));
    if (compileUnitPtr == ((void *) 0)) {
	struct SrcPosition	srcPos;
	TLSETL(100501);
	TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLINCL();
	srcPos.fileNo = compileFileNo;
	TLSETL(100506);
	Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Can\'t allocate memory for unit descriptor");
    };
    TLSETL(100510);
    FeedBack("Generating dependency graph");
    if ((Language_lastCompileUnit == ((void *) 0)) || (compileUnitPtr != Language_lastCompileUnit)) {
	TLSETL(100513);
	Language_UnitManager_ClearConfiguration();
	Language_lastCompileUnit = compileUnitPtr;
    };
    TLSETL(100517);
    Language_ScanPredefs();
    if (canBeUnit) {
	TLSETL(100519);
	Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 0);
    } else {
	TLSETL(100521);
	Language_ScanUnitPtr(compileUnitPtr, (Language_UnitManager_UnitKind) 3);
	if (Language_mainUnitPtr == ((void *) 0)) {
	    struct SrcPosition	srcPos;
	    TLSETL(100526);
	    TLSTRCTASS(srcPos, Language_nullSrcPosition, struct SrcPosition);
	    TLINCL();
	    srcPos.fileNo = compileFileNo;
	    TLSETL(100530);
	    Language_ErrorModule_Message(&(srcPos), (Language_ErrorModule_Severity) 3, "Cannot have unit as main program");
	};
    };
    TLSETL(100537);
    Language_CompileUnitPtr(compileUnitPtr);
    TLRESTORELF();
}

void Language_CompileUnit (fileName, fileNo, firstErrorMsg, errorCount)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100544);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100546);
	FileManager_CloseAllText();
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if (quitCode.quitCode != 1) {
	    TLSETL(100548);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100555);
	Language_CompileFile(fileName, (FileManager_FileNoType) fileNo, (TLboolean) 1);
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TL_TLE_TLEHX();
    }
}

void Language_WriteObjectFile (fileName, fileNo, firstErrorMsg, errorCount, objectFileStream)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
TLint4	objectFileStream;
{
    TLboolean	success;
    TLstring	mainFileName;
    FileManager_FileNoType	mainFileNo;
    TLSTKCHKSLF(100576);
    TLSETF();
    TLSETL(100576);
    Language_Compile_SetObjectFileStream((TLint4) objectFileStream);
    TLSETL(100580);
    Language_Reset();
    TLSETL(100585);
    Language_CompileProgram(fileName, (FileManager_FileNoType) fileNo, &((*firstErrorMsg)), &((*errorCount)));
    TLSETL(100589);
    Language_Compile_SetObjectFileStream((TLint4) 0);
    TLSTRASS(255, mainFileName, "***MAIN PROGRAM***");
    TLINCL();
    mainFileNo = Language_UnitManager_FileNo(Language_mainUnitPtr);
    TLSETL(100592);
    TL_TLI_TLISS ((TLint4) objectFileStream, (TLint2) 4);
    TL_TLI_TLIWR (&mainFileNo, (TLint4) sizeof mainFileNo, (TLaddressint) 0, (TLint2) objectFileStream);
    TL_TLI_TLIWR (mainFileName, (TLint4) 255, (TLaddressint) 0, (TLint2) objectFileStream);
    TLRESTORELF();
}

void Language_CompileProgram (fileName, fileNo, firstErrorMsg, errorCount)
TLstring	fileName;
FileManager_FileNoType	fileNo;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100600);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100602);
	FileManager_CloseAllText();
	TLINCL();
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if (quitCode.quitCode != 1) {
	    TLSETL(100604);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100614);
	Language_CompileFile(fileName, (FileManager_FileNoType) fileNo, (TLboolean) 0);
	TLINCL();
	for(;;) {
	    void	*unitPtr;
	    TLSETL(100617);
	    Language_UnitManager_RewindUnitList();
	    TLINCL();
	    for(;;) {
		void	*bodyUnit;
		TLSETL(100619);
		Language_UnitManager_GetNextUnit(&(unitPtr));
		if (unitPtr == ((void *) 0)) {
		    break;
		};
		TLSETL(100620);
		bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
		TLSETL(100622);
		if ((Language_UnitManager_IsCompiled(unitPtr) && (bodyUnit != ((void *) 0))) && (!Language_UnitManager_IsCompiled(bodyUnit))) {
		    TLSETL(100626);
		    Language_CompileUnitPtr(bodyUnit);
		    TLINCL();
		    break;
		};
	    };
	    TLSETL(100629);
	    if (unitPtr == ((void *) 0)) {
		break;
	    };
	};
	TLSETL(100633);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	if ((*errorCount) == 0) {
	    TLSETL(100635);
	    Language_UnitManager_FlushOldUnits();
	    TLINCL();
	    FileManager_FlushUnreferencedFiles();
	};
	TL_TLE_TLEHX();
    }
}
static TLboolean	Language_pendingError;

void Language_SetupExecution (maxStackSize, inName, outName, args, numArgs)
TLnat4	maxStackSize;
TLstring	inName;
TLstring	outName;
__x1108	args;
TLint4	numArgs;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100681);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100681);
	Language_pendingError = 1;
	TLSETL(100683);
	if (quitCode.quitCode != 1) {
	    TLSETL(100684);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLaddressint	startPC;
	TLSETF();
	TLSETL(100689);
	Language_pendingError = 0;
	TLSETL(100695);
	Language_ErrorModule_Initialize();
	TLINCL();
	Language_UnitManager_RewindUnitList();
	TLINCL();
	for(;;) {
	    void	*unitPtr;
	    TLaddressint	unitCode;
	    TLSETL(100700);
	    for(;;) {
		TLSETL(100701);
		Language_UnitManager_GetNextUnit(&(unitPtr));
		if (unitPtr == ((void *) 0)) {
		    break;
		};
		TLSETL(100702);
		if (Language_UnitManager_IsCompiled(unitPtr)) {
		    break;
		};
	    };
	    TLSETL(100704);
	    if (unitPtr == ((void *) 0)) {
		break;
	    };
	    TLSETL(100706);
	    unitCode = (TLaddressint) Language_UnitManager_CodeTable(unitPtr);
	    TLSETL(100711);
	    if ((unsigned long) unitCode != 0) {
		void	*bodyUnit;
		TLSETL(100712);
		bodyUnit = Language_UnitManager_BodyUnit(unitPtr);
		TLSETL(100714);
		if (bodyUnit == ((void *) 0)) {
		    TLSETL(100715);
		    (* (struct Language_CodeHeader *) unitCode).bodyCode = (TLaddressint) 0;
		} else {
		    TLSETL(100718);
		    for(;;) {
			void	*stubUnit;
			TLSETL(100718);
			stubUnit = Language_UnitManager_StubUnit(bodyUnit);
			TLSETL(100720);
			if (stubUnit == unitPtr) {
			    break;
			};
			TLSETL(100721);
			bodyUnit = stubUnit;
		    };
		    TLSETL(100723);
		    (* (struct Language_CodeHeader *) unitCode).bodyCode = (TLaddressint) ((unsigned long) Language_UnitManager_CodeTable(bodyUnit) + sizeof(struct Language_CodeHeader));
		};
	    };
	    TLSETL(100732);
	    {
		TLaddressint	globalArea;
		globalArea = (TLaddressint) Language_UnitManager_GlobalArea(unitPtr);
		TLINCL();
		if ((unsigned long) globalArea != 0) {
		    TLint4	globalSize;

		    extern void memset ();
		    TLSETL(100734);
		    globalSize = Language_UnitManager_GlobalSize(unitPtr);
		    TLINCL();
		    TLASSERT (globalSize != 0);
		    TLSETL(100739);
		    memset((TLaddressint) globalArea, (TLint4) 0, (TLint4) globalSize);
		};
	    };
	};
	TLSETL(100743);
	TLASSERT (Language_mainUnitPtr != ((void *) 0));
	TLINCL();
	startPC = (TLaddressint) ((unsigned long) Language_UnitManager_CodeTable(Language_mainUnitPtr) + sizeof(struct Language_CodeHeader));
	TLSETL(100750);
	Language_Execute_Initialize((TLaddressint) startPC, (TLnat4) maxStackSize, inName, outName, args, (TLint4) numArgs);
	TL_TLE_TLEHX();
    }
}

void Language_SetStep (step)
Language_Step	step;
{
    TLSTKCHKSLF(100759);
    TLSETF();
    TLSETL(100759);
    Language_Execute_SetStep((Language_Step) step);
    TLRESTORELF();
}
static TLaddressint	Language_unitInitPC;
static TLaddressint	Language_unitInitFP;

void Language_ExecuteProgram (runStatus, firstErrorMsg, errorCount)
struct Language_RunStatus	*runStatus;
struct ErrMsgDef	**firstErrorMsg;
TLint4	*errorCount;
{
    struct TLHAREA	quitCode;
    TLSTKCHKSLF(100775);
    if (TLHANDENTER(quitCode)) {
	TLSETF();
	TLSETL(100775);
	(*runStatus).state = 0;
	TLSETL(100777);
	TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	TLSETL(100779);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TLINCL();
	TL_TLI_TLIFS();
	if (quitCode.quitCode != 1) {
	    TLSETL(100781);
	    TL_TLE_TLEQUIT ((TLint4) quitCode.quitCode, (char *) 0, 1);
	};
    } else {
	TLSETF();
	TLSETL(100786);
	if (Language_pendingError) {
	    TLSETL(100787);
	    (*runStatus).state = 0;
	    TLINCL();
	    TLSTRCTASS((*runStatus).srcPos, Language_nullSrcPosition, struct SrcPosition);
	} else {
	    TLSETL(100791);
	    Language_unitInitPC = (TLaddressint) 0;
	    TLINCL();
	    Language_unitInitFP = (TLaddressint) 0;
	    TLSETL(100795);
	    Language_Execute_Executor(&((*runStatus)));
	    if (((*runStatus).state) == 0) {
		TLSETL(100796);
		Language_pendingError = 1;
		TLSETL(100798);
		TL_TLI_TLIFS();
	    };
	};
	TLSETL(100803);
	Language_ErrorModule_ReturnErrors(&((*firstErrorMsg)), &((*errorCount)));
	TL_TLE_TLEHX();
    }
}

void Language_EndExecution () {
    TLSTKCHKSLF(100809);
    TLSETF();
    TLSETL(100809);
    Language_Execute_EndExecution();
    Language_pendingError = 1;
    TLRESTORELF();
}

void Language_StopExecution () {
    TLSTKCHKSLF(100815);
    TLSETF();
    TLSETL(100815);
    TL_TLI_TLIFS();
    TLRESTORELF();
}

void Language_DumpThreadList (firstThreadQueue)
struct ThreadQueueDef	**firstThreadQueue;
{
    TLSTKCHKSLF(100821);
    TLSETF();
    TLSETL(100821);
    Language_Execute_DumpThreadList(&((*firstThreadQueue)));
    TLRESTORELF();
}

void Language_DumpUnitList (firstSymbol)
struct DumpSymbolDef	**firstSymbol;
{
    TLSTKCHKSLF(100827);
    TLSETF();
    TLSETL(100827);
    Language_Compile_DumpUnitList(&((*firstSymbol)));
    TLRESTORELF();
}

void Language_DumpScopeInfo (cookie, scopeInfo)
struct Cookie	*cookie;
struct DumpScopeDef	*scopeInfo;
{
    TLSTKCHKSLF(100832);
    TLSETF();
    TLSETL(100832);
    if ((unsigned long) Language_unitInitPC == 0) {
	TLSETL(100834);
	Language_Execute_UnitInitState(&(Language_unitInitPC), &(Language_unitInitFP));
    };
    TLSETL(100836);
    Language_Compile_DumpScopeInfo(&((*cookie)), (TLaddressint) Language_unitInitPC, (TLaddressint) Language_unitInitFP, &((*scopeInfo)));
    TLRESTORELF();
}

void Language_DumpSymbolInfo (cookie, firstSymbol)
struct Cookie	*cookie;
struct DumpSymbolDef	**firstSymbol;
{
    TLSTKCHKSLF(100842);
    TLSETF();
    TLSETL(100842);
    Language_Compile_DumpSymbolInfo(&((*cookie)), &((*firstSymbol)));
    TLRESTORELF();
}

void Language_DumpArrayBounds (cookie, firstIndex)
struct Cookie	*cookie;
struct DumpIndexDef	**firstIndex;
{
    TLSTKCHKSLF(100848);
    TLSETF();
    TLSETL(100848);
    Language_Compile_DumpArrayBounds(&((*cookie)), &((*firstIndex)));
    TLRESTORELF();
}

void Language_DumpArrayValues (cookie, dumpIndices, firstValue)
struct Cookie	*cookie;
struct DumpIndexDef	*dumpIndices;
struct DumpSymbolDef	**firstValue;
{
    TLSTKCHKSLF(100854);
    TLSETF();
    TLSETL(100854);
    Language_Compile_DumpArrayValues(&((*cookie)), dumpIndices, &((*firstValue)));
    TLRESTORELF();
}

extern void Paragrapher_Para ();

extern void Paragrapher_SetKeepCommentColumn ();

void Language_Paragraph (fileNo)
FileManager_FileNoType	fileNo;
{
    TLaddressint	textHandle;
    TLaddressint	sizePtr;
    FileManager_ResultCode	resultCode;
    TLaddressint	buffer;
    TLint4	bufferSize;
    TLSTKCHKSLF(100878);
    TLSETF();
    TLSETL(100878);
    TLPRE (fileNo != 0);
    TLSETL(100885);
    FileManager_OpenFileHandle((FileManager_FileNoType) fileNo, &(textHandle), &(sizePtr), &(resultCode));
    buffer = (TLaddressint) ((* (TLaddressint *) textHandle));
    TLINCL();
    bufferSize = (* (TLint4 *) sizePtr);
    TLSETL(100890);
    Paragrapher_Para(&(buffer), &(bufferSize));
    if ((unsigned long) buffer != 0) {
	TLSETL(100892);
	free((TLaddressint) ((* (TLaddressint *) textHandle)));
	(* (TLaddressint *) textHandle) = (TLaddressint) buffer;
	TLINCL();
	(* (TLint4 *) sizePtr) = bufferSize;
	TLSETL(100895);
	FileManager_SetModified((FileManager_FileNoType) fileNo);
    } else {
	TLSETL(100897);
	FeedBack("Paragraph failed!");
    };
    TLSETL(100900);
    FileManager_CloseFileHandle((FileManager_FileNoType) fileNo);
    TLRESTORELF();
}

void Language () {
    TLSAVELF();
    TLSETF();
    TLSETL(100039);
    Language_debug = 0;
    TLSETL(100080);
    Language_nullSymbolDef.next = (struct DumpSymbolDef *) 0;
    TLINCL();
    Language_nullSymbolDef.symbolName = (TLaddressint) 0;
    TLINCL();
    Language_nullSymbolDef.typeName = (TLaddressint) 0;
    TLINCL();
    TLSTRCTASS(Language_nullSymbolDef.srcPos, Language_nullSrcPosition, struct SrcPosition);
    TLINCL();
    TLSTRASS(255, Language_nullSymbolDef.value, "");
    TLINCL();
    TLSTRCTASS(Language_nullSymbolDef.cookie, Language_nullCookie, struct Cookie);
    TLINCL();
    Language_nullSymbolDef.isPredef = 0;
    TLSETL(100089);
    TLSTRCTASS(Language_nullScopeDef.symbolInfo, Language_nullSymbolDef, struct DumpSymbolDef);
    TLINCL();
    TLSTRCTASS(Language_nullScopeDef.expandCookie, Language_nullCookie, struct Cookie);
    TLINCL();
    Language_nullScopeDef.parameters = (struct DumpSymbolDef *) 0;
    TLINCL();
    Language_nullScopeDef.declarations = (struct DumpSymbolDef *) 0;
    Language_UnitManager();
    Language_ErrorModule();
    TLSETL(1000058);
    Language_codeOprSize =  TLSIMPLEMAX(2, 4);
    TLINCL();
    Language_codeInt1Size =  TLSIMPLEMAX(1, 4);
    TLINCL();
    Language_codeInt2Size =  TLSIMPLEMAX(2, 4);
    TLINCL();
    Language_codeIntSize =  TLSIMPLEMAX(4, 4);
    TLINCL();
    Language_codeRealSize =  TLSIMPLEMAX(8, 4);
    TLINCL();
    Language_codeAddrSize =  TLSIMPLEMAX(4, 4);
    TLINCL();
    Language_codeOffsetSize =  TL_TLA_TLAIMX ((TLint4) sizeof(Language_Offset), (TLint4) 4);
    TLSETL(1000176);
    TLASSERT (28 == sizeof(struct Language_ClassDescriptor));
    TLSETL(1000179);
    {
	typedef	TLaddressint	Address;
	typedef	TLint1	Int1;
	typedef	TLint2	Int2;
	typedef	TLint4	Int4;
	struct	ByteRecord {
    TLint1	fill;
    TLint1	data;
};
	struct	WordRecord {
    TLint1	fill;
    TLint2	data;
};
	struct	LongRecord {
    TLint1	fill;
    TLint4	data;
};
	TLINCL();
	TLASSERT (4 == sizeof(Address));
	TLINCL();
	TLASSERT (4 >= sizeof(Language_Offset));
	TLSETL(1000183);
	TLASSERT (2 == sizeof(Language_Opcode));
	TLSETL(1000186);
	TLASSERT (1 == sizeof(Int1));
	TLSETL(1000188);
	TLASSERT (2 == sizeof(Int2));
	TLSETL(1000190);
	TLASSERT (4 == sizeof(Int4));
	TLSETL(1000197);
	TLASSERT (1 == (sizeof(struct ByteRecord) - 1));
	TLSETL(1000204);
	TLASSERT (2 == (sizeof(struct WordRecord) - 2));
	TLSETL(1000211);
	TLASSERT (4 == (sizeof(struct LongRecord) - 4));
	TLSETL(1000213);
	TLASSERT (8 == sizeof(struct Language_PointerDescriptor));
    };
    Language_DebugModule();
    Language_Compile();
    Language_Execute();
    TLSETL(100189);
    Language_newPreprocs = 0;
    TLSETL(100452);
    Language_lastCompileUnit = (void *) 0;
    TLSETL(100765);
    Language_unitInitPC = (TLaddressint) 0;
    TLINCL();
    Language_unitInitFP = (TLaddressint) 0;
    Paragrapher();
    TLRESTORELF();
}
